package module

import (
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/Masterminds/sprig/v3"
	"github.com/lyft/protoc-gen-star"
	"github.com/lyft/protoc-gen-star/lang/go"

	rtkquerypb "github.com/thegrumpylion/protoc-gen-rtk-query/proto/rtkquery"
)

type Module struct {
	*pgs.ModuleBase
	ctx pgsgo.Context
}

func RTKQuery() pgs.Module { return &Module{ModuleBase: &pgs.ModuleBase{}} }

func (m *Module) InitContext(ctx pgs.BuildContext) {
	m.ModuleBase.InitContext(ctx)
	m.ctx = pgsgo.InitContext(ctx.Parameters())
}

func (m *Module) Name() string { return "rtk-query" }

func (m *Module) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {

  for f, imp := range mkImports(targets, pkgs) {
    m.Log(f)
    for ts, msgs := range imp {
      m.Logf("import { ")
      for as, msg := range msgs {
        if as != msg {
          m.Logf("  %s as %s, ", msg, as)
          continue
        }
        m.Logf("  %s, ", msg)
      }
      m.Logf("} from '%s'\n", ts)
    }
  }

	tpl := template.New("")

  sprigFuncMap := sprig.GenericFuncMap()

  localFuncMap := map[string]interface{}{
		"pkg":    m.ctx.PackageName,
		"server": m.ctx.ServerName,
		"endpoint": func(m pgs.Method) string {
			var q rtkquerypb.MethodOptions
			ok, err := m.Extension(rtkquerypb.E_Query, &q)
			if err != nil {
				return err.Error()
			}
			if ok {
				return q.EndpointType.String()
			}
			return ""
		},
    "lowerFirst": func(s pgs.Name) string {
      for i, v := range s {
          return string(unicode.ToLower(v)) + string(s[i+1:])
      }
      return ""
    },
    "fname": func(s pgs.Name) string {
      return strings.TrimSuffix(filepath.Base(s.String()), filepath.Ext(s.String()))
    },
    "fnamelc": func(s pgs.Name) string {
      fn := strings.TrimSuffix(filepath.Base(s.String()), filepath.Ext(s.String()))
      return pgs.Name(strings.ReplaceAll(fn, "-", ".")).LowerCamelCase().String()
    },
	}

  tpl.Funcs(mergeFuncMaps(sprigFuncMap, localFuncMap))

	template.Must(tpl.Parse(fileTpl))

	for n, f := range targets {
    m.Log("file: ", n)
		m.Push(f.Name().String())
		out := m.ctx.OutputPath(f)
		out = out.SetExt(".api.ts")
		m.AddGeneratorTemplateFile(out.String(), tpl, f)
		m.Pop()
	}

	return m.Artifacts()
}

func mkImports(targets map[string]pgs.File, pkgs map[string]pgs.Package) (ret map[string]map[string]map[string]string) {
  ret = map[string]map[string]map[string]string{}
  for n, f := range targets {
    ret[n] = map[string]map[string]string{}
    localmsgs := map[string]pgs.Message{}
    imports := map[string][]pgs.Message{}
    for _, m := range f.AllMessages() {
      localmsgs[string(m.Name().UpperCamelCase())] = m
    }
    for _, s := range f.Services() {
      for _, m := range s.Methods() {
        if m.Input().Package() != f.Package() {
          imports[string(m.Input().File().Name())] = append(imports[string(m.Input().File().Name())], m.Input())
        }
        if m.Output().Package() != f.Package() {
          imports[string(m.Output().File().Name())] = append(imports[string(m.Output().File().Name())], m.Output())
        }
      }
    }
    for fn, msgs := range imports {
      ret[n][strings.TrimSuffix(fn, "proto") + "ts"] = map[string]string{}
      m := ret[n][strings.TrimSuffix(fn, "proto") + "ts"]
      for _, msg := range msgs {
        nmo := msg.Name().UpperCamelCase().String()
        nm := nmo
        if _, ok := localmsgs[nm]; ok {
            nm = nm + "$" 
        }
        for {
          if _, ok := m[nm]; !ok {
            m[nm] = nmo
            break
          }
          nm = nm + "$" 
        }
      }
    }
  }
  return ret
}

func mergeFuncMaps(maps ...map[string]interface{}) map[string]interface{} {
	fm := make(map[string]interface{})
  for _, m := range maps {
    for k, v := range m {
      fm[k] = v
    }
  } 
  return fm
}

var _ pgs.Module = (*Module)(nil)

const fileTpl = `// Code generated by protoc-gen-rtk-query. DO NOT EDIT.
// source: {{ .InputPath }}
// {{.Name}}
{{- $fn := fname .Name}}
{{- $fnl := fnamelc .Name}}

import { createApi } from '@reduxjs/toolkit/query/react'
import { grpcBaseQuery } from "../api/base";
import { GrpcWebFetchTransport } from "@protobuf-ts/grpcweb-transport";
import * as {{$fnl}}Types from '../gen/{{$fn}}'
import * as {{$fnl}}Clients from "../gen/{{$fn}}.client";

const transport = new GrpcWebFetchTransport({
  baseUrl: "http://localhost:5080"
});

{{ range .Services }}
{{- $sn := .Name }}
{{- $snl := .Name.LowerCamelCase }}

const {{$snl}}Client = new {{$fnl}}Clients.{{$sn}}Client(transport)

// Define a service using a base URL and expected endpoints
export const {{$snl}} = createApi({
  reducerPath: '{{$snl}}',
  baseQuery: grpcBaseQuery(),
  endpoints: (builder) => ({
{{- range .Methods }}
{{- $mn := .Name }}
{{- $mnl := .Name | lowerFirst }}
    {{$mnl}}: builder.{{if eq (endpoint .) "QUERY"}}query{{else}}mutation{{end}}<{{$fnl}}Types.{{.Output.Name}}, {{$fnl}}Types.{{.Input.Name}}>({
      query: (req) => {{$snl}}Client.{{$mnl}}(req)
    }),
{{- end }}
  }),
})

// Export hooks for usage in function components, which are
// auto-generated based on the defined endpoints
export const {
{{- range .Methods }}
  use{{.Name}}{{if eq (endpoint .) ("QUERY")}}Query{{else}}Mutation{{end}},
{{- end }}
} = {{$snl}}
{{ end }}
`
